Index: expression/src/main/scala/com/phasmidsoftware/number/expression/parse/NumberParser.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.phasmidsoftware.number.expression.parse\n\nimport com.phasmidsoftware.number.core.inner.{Factor, PureNumber, Rational}\nimport com.phasmidsoftware.number.core.numerical.*\nimport com.phasmidsoftware.number.core.numerical.WithFuzziness.{Asterisk, Ellipsis}\n\nimport scala.util.Try\n\n/**\n  * Parser for Number.\n  *\n  * NOTE when we specify an exact number by following an integer by an exponent, we must precede the \"E\" with a decimal point.\n  * CONSIDER Try to eliminate that requirement.\n  */\nabstract class BaseNumberParser extends BaseRationalParser {\n\n  /**\n    * Parse the string w as a Number.\n    * The string consists of two optional parts:\n    * the numerator and the factor.\n    * Either of these can be missing but not both.\n    *\n    * @param w the String to parse.\n    * @return a Number, wrapped in Try.\n    */\n  def parseNumber(w: String): Try[Number] = stringParser(number, w)\n\n  trait WithFuzziness {\n    def fuzz: Option[Fuzziness[Double]]\n  }\n\n  /**\n    * Parser class to represent a number with fuzziness.\n    *\n    * @param realNumber    a representation of a real (decimal) number in String form.\n    * @param fuzziness     optional Gaussian fuzziness (as a String)--from a parenthetical number; if None, we have Box fuzziness (corresponding to \"*\").\n    * @param maybeExponent optional exponent (as a String).\n    */\n  case class NumberWithFuzziness(realNumber: RealNumber, fuzziness: Option[String], maybeExponent: Option[String]) extends ValuableNumber with WithFuzziness {\n\n    def value: Try[Rational] =\n      realNumber.value.map(r => r.applyExponent(getExponent))\n\n    def fuzz: Option[Fuzziness[Double]] = fuzziness match {\n      case None => None // No fuzz marker = exact number\n      case Some(Asterisk | Ellipsis) => calculateFuzz(getExponent + realNumber.exponent.map(_.toInt).getOrElse(0), realNumber.fractionalPart.length)\n      case Some(z) =>\n        val gaussian = \"\"\"\\((\\d*)\\)\"\"\".r\n        val box = \"\"\"\\[(\\d*)]\"\"\".r\n        val (shape, w) = z match {\n          case gaussian(f) => (Gaussian, f)\n          case box(f) => (Box, f)\n          case _ => throw SignificantSpaceParserException(s\"fuzziness does not match either (xx) or [xx]: $z\")\n        }\n        val zo: Option[Int] = w match {\n          case s if s.length >= 2 => s.substring(0, 2).toIntOption\n          case s => s.toIntOption\n        }\n        zo map (x => {\n          val i = getExponent - realNumber.fractionalPart.length\n          AbsoluteFuzz[Double](Rational(x).applyExponent(i).toDouble, shape)\n        })\n    }\n\n    // CONSIDER making this a method and having two places call it\n    private def getExponent = maybeExponent.getOrElse(\"0\").toInt\n  }\n\n  /**\n    * Parses a token representing a number. The parsing process may provide\n    * a default fuzzy number if no explicit number is identified. The result\n    * is tagged for clarity to indicate the type of parser.\n    *\n    * @return a Parser that yields a Number instance. If the parsing does not\n    *         identify a concrete number, it defaults to a FuzzyNumber.\n    */\n  def number: Parser[Number] =\n    maybeNumber :| \"number\" ^^ { no => no.getOrElse(FuzzyNumber()) }\n\n  /**\n    * This method defines a parser that attempts to parse an optional numerical value.\n    * The parser evaluates two optional components: a general number and a factor.\n    * It returns an optional `Number`, based on the combination of these parsed components.\n    * The parsing process is labeled as \"maybeNumber\".\n    *\n    * @return a `Parser` that yields an `Option[Number]`.\n    *         The result is `Some(Number)` if either a general number or a factor is parsed,\n    *         or `None` if neither component is present.\n    */\n  def maybeNumber: Parser[Option[Number]] =\n    (opt(generalNumber) ~ opt(factor)) :| \"maybeNumber\" ^^ {\n      case no ~ fo => optionalNumber(no, fo)\n    }\n\n  /**\n    * Method to parse fuzz, consisting of the strings \"*\", \"...\", or one or two digits enclosed in () or [].\n    *\n    * @return a Parser of an optional String.\n    *         If the String is None, then it is general fuzz (* or ...) otherwise Some(digits).\n    */\n  def fuzz: Parser[Option[String]] = {\n    // NOTE don't take the Analyzer's suggestion to remove escapes.\n    val fuzzyDigits = \"\"\"[\\(\\[]\\d{1,2}[\\)\\]]\"\"\".r\n    (\"\"\"\\*\"\"\".r | \"\"\"\\.\\.\\.\"\"\".r | fuzzyDigits) :| \"fuzz\" ^^ {\n      case w@Asterisk => Some(w) // Changed: return Some(\"*\") to distinguish from ellipsis\n      case w@Ellipsis => Some(w) // Changed: return Some(\"...\") to mark as ellipsis\n      case w => Some(w)\n    }\n  }\n\n  /**\n    * Parses either a number with fuzziness or a rational number.\n    * This method combines the parsing of two distinct numeric formats:\n    * - A number with an optional degree of fuzziness.\n    * - A rational representation of a number.\n    *   The parser attempts to parse input and tag the result as `generalNumber`.\n    *\n    * @return a Parser that yields a ValuableNumber.\n    *         The result is determined by the successful parsing of one of the numeric formats.\n    */\n  def generalNumber: Parser[ValuableNumber] =\n    (numberWithFuzziness | rationalNumber) :| \"generalNumber\"\n\n  /**\n    * Parses a representation of a number that includes an optional degree of fuzziness\n    * and an optional exponent. The parser expects a combination of a real number,\n    * fuzziness indicator, and possibly an exponent. The fuzziness can represent\n    * uncertainty or range encoded in specific formats like \"*\", \"...\", or digits in\n    * parentheses or brackets.\n    *\n    * @return a Parser that yields a `NumberWithFuzziness` instance. The result contains\n    *         the parsed real number, the optional fuzz description, and the optional\n    *         exponent value.\n    */\n  def numberWithFuzziness: Parser[NumberWithFuzziness] =\n    (realNumber ~ fuzz ~ opt(exponent)) :| \"numberWithFuzziness\" ^^ {\n      case rn ~ f ~ expo => NumberWithFuzziness(rn, f, expo)\n    }\n\n  // NOTE: if you copy numbers from HTML, you may end up with an illegal \"-\" character.\n  // Error message will be something like: string matching regex '-?\\d+' expected but '−' found\n  def exponent: Parser[String] =\n    (rE ~> wholeNumber) :| \"exponent\"\n\n  private val rE = \"[eE]\".r\n\n  // NOTE: maximum length for an exact number.\n  //  Any number with a longer fractional part is assumed to be fuzzy.\n  private val DecimalPlacesExact = 14\n\n  protected def optionalNumber(ro: Option[ValuableNumber], fo: Option[Factor]): Option[Number] =\n    if (ro.isDefined || fo.isDefined)\n      for (\n        r <- ro.orElse(Some(WholeNumber.one));\n        v <- r.value.toOption;\n        f <- fo.orElse(Some(PureNumber))) yield {\n        val z: Option[Fuzziness[Double]] = r match {\n          case n@NumberWithFuzziness(_, _, _) => n.fuzz\n          case n@RealNumber(_, _, Some(f), _) if f.length > DecimalPlacesExact && !f.endsWith(\"00\") => calculateFuzz(n.exponent.getOrElse(\"0\").toInt, f.length)\n          case _ => None\n        }\n        Number.apply(v, f, z)\n      }\n    else None\n\n  /**\n    * Calculates fuzziness based on the given exponent and decimal places.\n    *\n    * @param exponent      the exponent used in the calculation, representing the magnitude.\n    * @param decimalPlaces the number of decimal places to account for in the calculation.\n    * @return an `Option` containing a `Fuzziness[Double]` instance if the calculation succeeds.\n    */\n  private def calculateFuzz(exponent: Int, decimalPlaces: Int): Option[Fuzziness[Double]] =\n    Some(AbsoluteFuzz[Double](Rational(5).applyExponent(exponent - decimalPlaces - 1).toDouble, Box))\n\n  import Factor.*\n\n  /**\n    * Parses a factor from the input. A factor can represent specific mathematical constants,\n    * symbols, or degrees. The parser attempts to match various predefined symbols such as\n    * a percentage sign, degree symbol, multiple representations of π, or Euler's number.\n    * If none of these are matched, the parser will fail with a defined error message.\n    *\n    * @return a `Parser` that produces a `Factor` instance.\n    *         The result encapsulates the matched symbol or numerical value of the factor.\n    */\n  def factor: Parser[Factor] = (sPercent | sDegree | sPi | sPiAlt0 | sPiAlt1 | sPiAlt2 | sE | failure(\"factor\")) :| \"factor\" ^^ { w => Factor(w) }\n}\n\n/**\n  * Object for parsing numerical values, extending the functionality of the\n  * `BaseNumberParser` class. Provides methods for parsing, interpreting, and\n  * representing numbers, potentially with fuzziness, exponents, and other\n  * modifications.\n  *\n  * This object specializes in defining the parsing rules for various numeric\n  * representations, including:\n  * - Simple numbers or rational numbers.\n  * - Numbers with fuzziness or uncertainty.\n  * - Factors representing constants, symbols, or mathematical concepts.\n  *\n  * The parsing logic accounts for optional components such as fractional parts\n  * and exponents, and encapsulates results within domain-specific types, such\n  * as `Number`, `NumberWithFuzziness`, and `ValuableNumber`.\n  */\nobject NumberParser extends BaseNumberParser\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/expression/src/main/scala/com/phasmidsoftware/number/expression/parse/NumberParser.scala b/expression/src/main/scala/com/phasmidsoftware/number/expression/parse/NumberParser.scala
--- a/expression/src/main/scala/com/phasmidsoftware/number/expression/parse/NumberParser.scala	(revision 894c4c8efbf849fba91c0a888d9bf42d809b8f06)
+++ b/expression/src/main/scala/com/phasmidsoftware/number/expression/parse/NumberParser.scala	(date 1771540440062)
@@ -139,8 +139,11 @@
 
   // NOTE: if you copy numbers from HTML, you may end up with an illegal "-" character.
   // Error message will be something like: string matching regex '-?\d+' expected but '−' found
+  //  def exponent: Parser[String] =
+  //    (rE ~> """\+?""".r ~> wholeNumber) :| "exponent"
+
   def exponent: Parser[String] =
-    (rE ~> wholeNumber) :| "exponent"
+    (rE ~> """\+?-?\d+""".r) :| "exponent"
 
   private val rE = "[eE]".r
 
Index: core/src/main/scala/com/phasmidsoftware/number/core/parse/NumberParser.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (c) 2025. Phasmid Software\n */\n\npackage com.phasmidsoftware.number.core.parse\n\nimport com.phasmidsoftware.number.core.inner.{Factor, PureNumber, Rational}\nimport com.phasmidsoftware.number.core.numerical.*\nimport com.phasmidsoftware.number.core.numerical.WithFuzziness.{Asterisk, Ellipsis}\n\nimport scala.util.Try\n\n/**\n  * Parser for Number.\n  *\n  * NOTE when we specify an exact number by following an integer by an exponent, we must precede the \"E\" with a decimal point.\n  * CONSIDER Try to eliminate that requirement.\n  */\n@deprecated(\"use com.phasmidsoftware.number.expression.parse.BaseNumberParser instead\", \"1.6.5\")\nabstract class BaseNumberParser extends BaseRationalParser {\n\n  /**\n    * Parse the string w as a Number.\n    * The string consists of two optional parts:\n    * the numerator and the factor.\n    * Either of these can be missing but not both.\n    *\n    * @param w the String to parse.\n    * @return a Number, wrapped in Try.\n    */\n  def parseNumber(w: String): Try[Number] =\n    stringParser(number, w)\n\n  /**\n    * Parser class to represent a number with fuzziness.\n    *\n    * @param realNumber    a representation of a real (decimal) number in String form.\n    * @param fuzziness     optional Gaussian fuzziness (as a String)--from a parenthetical number; if None, we have Box fuzziness (corresponding to \"*\").\n    * @param maybeExponent optional exponent (as a String).\n    */\n  case class NumberWithFuzziness(realNumber: RealNumber, fuzziness: Option[String], maybeExponent: Option[String]) extends ValuableNumber with WithFuzziness {\n\n    def value: Try[Rational] =\n      realNumber.value.map(r => r.applyExponent(getExponent))\n\n    def fuzz: Option[Fuzziness[Double]] = fuzziness match {\n      case None => None // No fuzz marker = exact number\n      case Some(Asterisk | Ellipsis) => calculateFuzz(getExponent + realNumber.exponent.map(_.toInt).getOrElse(0), realNumber.fractionalPart.length)\n      case Some(z) =>\n        val gaussian = \"\"\"\\((\\d*)\\)\"\"\".r\n        val box = \"\"\"\\[(\\d*)]\"\"\".r\n        val (shape, w) = z match {\n          case gaussian(f) => (Gaussian, f)\n          case box(f) => (Box, f)\n          case _ => throw SignificantSpaceParserException(s\"fuzziness does not match expected patterns: $z\")\n        }\n        val zo: Option[Int] = w match {\n          case s if s.length >= 2 => s.substring(0, 2).toIntOption\n          case s => s.toIntOption\n        }\n        zo map (x => {\n          val i = getExponent - realNumber.fractionalPart.length\n          AbsoluteFuzz[Double](Rational(x).applyExponent(i).toDouble, shape)\n        })\n    }\n\n    // CONSIDER making this a method and having two places call it\n    private def getExponent =\n      maybeExponent.getOrElse(\"0\").toInt\n  }\n\n  /**\n    * Parses a token representing a number. The parsing process may provide\n    * a default fuzzy number if no explicit number is identified. The result\n    * is tagged for clarity to indicate the type of parser.\n    *\n    * @return a Parser that yields a Number instance. If the parsing does not\n    *         identify a concrete number, it defaults to a FuzzyNumber.\n    */\n  def number: Parser[Number] =\n    maybeNumber :| \"number\" ^^ { no => no.getOrElse(FuzzyNumber()) }\n\n  /**\n    * This method defines a parser that attempts to parse an optional numerical value.\n    * The parser evaluates two optional components: a general number and a factor.\n    * It returns an optional `Number`, based on the combination of these parsed components.\n    * The parsing process is labeled as \"maybeNumber\".\n    *\n    * @return a `Parser` that yields an `Option[Number]`.\n    *         The result is `Some(Number)` if either a general number or a factor is parsed,\n    *         or `None` if neither component is present.\n    */\n  def maybeNumber: Parser[Option[Number]] =\n    (opt(generalNumber) ~ opt(factor)) :| \"maybeNumber\" ^^ {\n      case no ~ fo => optionalNumber(no, fo)\n    }\n\n  /**\n    * Method to parse fuzz, consisting of the strings \"*\", \"...\", or one or two digits enclosed in () or [].\n    *\n    * @return a Parser of an optional String.\n    *         If the String is None, then it is general fuzz (* or ...) otherwise Some(digits).\n    */\n  def fuzz: Parser[Option[String]] = {\n    val fuzzyDigits = \"\"\"[\\(\\[]\\d{1,2}[\\)\\]]\"\"\".r\n    (\"\"\"\\*\"\"\".r | \"\"\"\\.\\.\\.\"\"\".r | fuzzyDigits) :| \"fuzz\" ^^ {\n      case w@Asterisk => Some(w) // Changed: return Some(\"*\") to distinguish from ellipsis\n      case w@Ellipsis => Some(w) // Changed: return Some(\"...\") to mark as ellipsis\n      case w => Some(w)\n    }\n  }\n\n  /**\n    * Parses either a number with fuzziness or a rational number.\n    * This method combines the parsing of two distinct numeric formats:\n    * - A number with an optional degree of fuzziness.\n    * - A rational representation of a number.\n    * The parser attempts to parse input and tag the result as `generalNumber`.\n    *\n    * @return a Parser that yields a ValuableNumber.\n    *         The result is determined by the successful parsing of one of the numeric formats.\n    */\n  def generalNumber: Parser[ValuableNumber] =\n    (numberWithFuzziness | rationalNumber) :| \"generalNumber\"\n\n  /**\n    * Parses a representation of a number that includes an optional degree of fuzziness\n    * and an optional exponent. The parser expects a combination of a real number,\n    * fuzziness indicator, and possibly an exponent. The fuzziness can represent\n    * uncertainty or range encoded in specific formats like \"*\", \"...\", or digits in\n    * parentheses or brackets.\n    *\n    * @return a Parser that yields a `NumberWithFuzziness` instance. The result contains\n    *         the parsed real number, the optional fuzz description, and the optional\n    *         exponent value.\n    */\n  def numberWithFuzziness: Parser[NumberWithFuzziness] =\n    (realNumber ~ fuzz ~ opt(exponent)) :| \"numberWithFuzziness\" ^^ {\n      case rn ~ f ~ expo => NumberWithFuzziness(rn, f, expo)\n    }\n\n  // NOTE: if you copy numbers from HTML, you may end up with an illegal \"-\" character.\n  // Error message will be something like: string matching regex '-?\\d+' expected but '−' found\n  def exponent: Parser[String] =\n    (rE ~> wholeNumber) :| \"exponent\"\n\n  private val rE = \"[eE]\".r\n\n  // NOTE: maximum length for an exact number. (Does this only apply to numbers presented in String form?)\n  //  Any number with a longer fractional part is assumed to be fuzzy.\n  private val DecimalPlacesExact = 14\n\n  private def optionalNumber(ro: Option[ValuableNumber], fo: Option[Factor]): Option[Number] =\n    if (ro.isDefined || fo.isDefined)\n      for (\n        r <- ro.orElse(Some(WholeNumber.one));\n        v <- r.value.toOption;\n        f <- fo.orElse(Some(PureNumber))) yield {\n        val z: Option[Fuzziness[Double]] = r match {\n          case n@NumberWithFuzziness(_, _, _) => n.fuzz\n          case n@RealNumber(_, _, Some(f), _) if f.length > DecimalPlacesExact && !f.endsWith(\"00\") => calculateFuzz(n.exponent.getOrElse(\"0\").toInt, f.length)\n          case _ => None\n        }\n        Number.apply(v, f, z)\n      }\n    else None\n\n  /**\n    * Calculates fuzziness based on the given exponent and decimal places.\n    *\n    * @param exponent      the exponent used in the calculation, representing the magnitude.\n    * @param decimalPlaces the number of decimal places to account for in the calculation.\n    * @return an `Option` containing a `Fuzziness[Double]` instance if the calculation succeeds.\n    */\n  private def calculateFuzz(exponent: Int, decimalPlaces: Int): Option[Fuzziness[Double]] =\n    Some(AbsoluteFuzz[Double](Rational(5).applyExponent(exponent - decimalPlaces - 1).toDouble, Box))\n\n  import Factor.*\n\n  /**\n    * Parses a factor from the input. A factor can represent specific mathematical constants,\n    * symbols, or degrees. The parser attempts to match various predefined symbols such as\n    * a percentage sign, degree symbol, multiple representations of π, or Euler's number.\n    * If none of these are matched, the parser will fail with a defined error message.\n    *\n    * @return a `Parser` that produces a `Factor` instance.\n    *         The result encapsulates the matched symbol or numerical value of the factor.\n    */\n  def factor: Parser[Factor] = (sPercent | sDegree | sPi | sPiAlt0 | sPiAlt1 | sPiAlt2 | sE | failure(\"factor\")) :| \"factor\" ^^ { w => Factor(w) }\n}\n\n/**\n  * Object for parsing numerical values, extending the functionality of the\n  * `BaseNumberParser` class. Provides methods for parsing, interpreting, and\n  * representing numbers, potentially with fuzziness, exponents, and other\n  * modifications.\n  *\n  * This object specializes in defining the parsing rules for various numeric\n  * representations, including:\n  * - Simple numbers or rational numbers.\n  * - Numbers with fuzziness or uncertainty.\n  * - Factors representing constants, symbols, or mathematical concepts.\n  *\n  * The parsing logic accounts for optional components such as fractional parts\n  * and exponents, and encapsulates results within domain-specific types, such\n  * as `Number`, `NumberWithFuzziness`, and `ValuableNumber`.\n  */\n@deprecated(\"use com.phasmidsoftware.number.expression.parse.NumberParser instead\", \"1.6.5\")\nobject NumberParser extends BaseNumberParser\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/main/scala/com/phasmidsoftware/number/core/parse/NumberParser.scala b/core/src/main/scala/com/phasmidsoftware/number/core/parse/NumberParser.scala
--- a/core/src/main/scala/com/phasmidsoftware/number/core/parse/NumberParser.scala	(revision 894c4c8efbf849fba91c0a888d9bf42d809b8f06)
+++ b/core/src/main/scala/com/phasmidsoftware/number/core/parse/NumberParser.scala	(date 1771540440077)
@@ -141,8 +141,11 @@
 
   // NOTE: if you copy numbers from HTML, you may end up with an illegal "-" character.
   // Error message will be something like: string matching regex '-?\d+' expected but '−' found
+  //  def exponent: Parser[String] =
+  //    (rE ~> """\+?""".r ~> wholeNumber) :| "exponent"
+
   def exponent: Parser[String] =
-    (rE ~> wholeNumber) :| "exponent"
+    (rE ~> """\+?-?\d+""".r) :| "exponent"
 
   private val rE = "[eE]".r
 
