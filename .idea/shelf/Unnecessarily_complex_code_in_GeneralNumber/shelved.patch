Index: core/src/main/scala/com/phasmidsoftware/number/core/numerical/GeneralNumber.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (c) 2023. Phasmid Software\n */\n\npackage com.phasmidsoftware.number.core.numerical\n\nimport com.phasmidsoftware.number.core.inner.*\nimport com.phasmidsoftware.number.core.inner.Operations.doTransformValueMonadic\nimport com.phasmidsoftware.number.core.inner.Rational.toInts\nimport com.phasmidsoftware.number.core.misc.FP\nimport com.phasmidsoftware.number.core.numerical.GeneralNumber.normalizeRoot\nimport com.phasmidsoftware.number.core.numerical.Number.{negate, one, prepareWithSpecialize}\n\nimport scala.annotation.tailrec\nimport scala.util.*\n\n/**\n  * This class is designed to model a Numerical value of various possible different types and of various possible factors.\n  * The types are: Int, BigInt, Rational, Double.\n  * The factors are: Scalar, Logarithmic, and NthRoot (with various subtypes).\n  *\n  * TODO continue refactoring to merge similar methods, particularly in GeneralNumber and FuzzyNumber.\n  *\n  * @param nominalValue the nominalValue of the Number, expressed as a nested Either type.\n  * @param factor       the scale factor of the Number: valid scales are: PureNumber, Radian, and NatLog.\n  * @param fuzz         the (optional) fuzziness of this Number.\n  */\nabstract class GeneralNumber(val nominalValue: Value, val factor: Factor, val fuzz: Option[Fuzziness[Double]]) extends Number with Fuzz[Double] {\n\n  self =>\n\n  /**\n    * Method to compare this Number with that Field.\n    * Required by implementing Ordered[Field].\n    *\n    * @param that (a Field).\n    * @return the comparison.\n    */\n  def compare(that: Field): Int = (this, that) match {\n    case (x: FuzzyNumber, Real(y)) =>\n      x.compare(y)\n    case (x: ExactNumber, Real(y)) =>\n      x.compare(y)\n    case _ =>\n      that.compare(Real(this))\n  }\n\n  /**\n    * Method to determine if this is a valid Number.\n    * An invalid number has a value of form Left(Left(Left(None)))\n    *\n    * @return true if this is a valid Number\n    */\n  lazy val isValid: Boolean =\n    maybeNominalDouble.isDefined\n\n  /**\n    *\n    * @return true if the value of this GeneralNumber is one.\n    */\n  lazy val isUnity: Boolean =\n    doSubtract(Number.one).isZero\n\n  /**\n    * Method to apply a function to this Number.\n    *\n    * @param f      a function Double=>Double.\n    * @param dfByDx the first derivative of f.\n    * @return a Try[Number] which is the result of applying f to this Number.\n    */\n  def applyFunc(f: Double => Double, dfByDx: Double => Double): Try[Number] =\n    GeneralNumber.applyFunc(f, dfByDx)(this)\n\n  /**\n    * Method to get the nominalValue of this Number as a Rational.\n    * If this is actually a Double, it will be converted to a Rational according to the implicit conversion from Double to Rational.\n    * See Rational.convertDouble(x).\n    *\n    * @return an Option of Rational.\n    */\n  lazy val toNominalRational: Option[Rational] = maybeNominalRational\n\n  /**\n    * Method to get the nominalValue of this Number as an Int.\n    *\n    * @return an Option of Int. If this Number cannot be converted to an Int, then None will be returned.\n    */\n  lazy val toInt: Option[Int] = maybeInt\n\n  /**\n    * Method to get the nominalValue of this Number as an (optional) BigInt.\n    * This will return Some(x) only if this is an Int, or a Rational with unit denominator.\n    *\n    * @return an Option of BigInt.\n    */\n  lazy val toBigInt: Option[BigInt] = nominalValue match {\n    case Right(x) =>\n      Some(BigInt(x))\n    case Left(Right(r)) if r.isWhole =>\n      Some(r.n)\n    case _ =>\n      None\n  }\n\n  /**\n    * Method to get the nominalValue of this Number as an (optional) BigInt.\n    * This will return Some(x) only if this is an Int, or a Rational with unit denominator.\n    *\n    * TESTME\n    *\n    * @return an Option of BigDecimal.\n    */\n  lazy val toBigDecimal: Option[BigDecimal] = nominalValue match {\n    case Right(x) =>\n      Some(BigDecimal(x))\n    case Left(Right(r)) =>\n      r.toBigDecimal\n    case Left(Left(Some(x))) =>\n      Some(BigDecimal(x))\n    case _ =>\n      None\n  }\n\n  /**\n    * @return true if this Number is equal to zero.\n    */\n  lazy val isInfinite: Boolean =\n    GeneralNumber.isInfinite(this)\n\n  /**\n    * Method to determine if this Number is positive.\n    * Use case: does the String representation not start with a \"-\"?\n    *\n    * CONSIDER evaluating toString instead.\n    *\n    * @return true if this Number is greater than or equal to 0.\n    */\n  lazy val isPositive: Boolean =\n    signum >= 0\n\n  /**\n    * Method to determine if this Number is actually represented as an Integer.\n    *\n    * @return true if exact and rational.\n    */\n  lazy val isInteger: Boolean = nominalValue match {\n    case Right(_) =>\n      true\n    case _ =>\n      false\n  }\n\n  /**\n    * Method to determine if this Number is actually represented as a Rational.\n    *\n    * @return true if exact and rational.\n    */\n  lazy val isRational: Boolean = nominalValue match {\n    case Left(Right(_)) =>\n      true\n    case _ =>\n      false\n  }\n\n  /**\n    * Method to determine if this is an imaginary Number,\n    * that's to say a number with negative nominalValue and SquareRoot as its factor.\n    *\n    * @return true if imaginary.\n    */\n  lazy val isImaginary: Boolean = factor match {\n    case SquareRoot if Value.signum(nominalValue) < 0 =>\n      true\n    case _ =>\n      false\n  }\n\n  /**\n    * Negative of this Number.\n    */\n  lazy val makeNegative: Number =\n    negate(this) //doMultiply(Number(-1))\n\n  /**\n    * Divide this Number by n.\n    *\n    * @param n another Number.\n    * @return this quotient of this and n, i.e. this/n.\n    */\n  def doDivide(n: Number): Number =\n    doMultiply(Number.inverse(n))\n\n  /**\n    * Yields the square root of this Number.\n    * The result will be exact.\n    */\n  lazy val sqrt: Number =\n    Number.sqrt(this)\n\n  /**\n    * Method to determine the sine of this Number.\n    * The result will be a Number with PureNumber factor.\n    *\n    * @return the sine of this.\n    */\n  lazy val sin: Number =\n    Number.sin(this)\n\n  /**\n    * Method to determine the cosine of this Number.\n    * The result will be a Number with PureNumber factor.\n    *\n    * @return the cosine.\n    */\n  lazy val cos: Number =\n    Number.negate(negate(scale(Radian)) `doAdd` Number(Rational.half, Radian).makeNegative).sin\n\n  /**\n    * Calculate the angle whose opposite length is y and whose adjacent length is this.\n    *\n    * @param y the opposite length\n    * @return the angle defined by x = this, y = y\n    */\n  def atan(y: Number): Number =\n    Number.atan(this, y)\n\n  /**\n    * Calculates the logarithm of the current number to the given base.\n    *\n    * @param b the base of the logarithm\n    * @return the logarithm of the current number to the given base, or NaN if the calculation fails\n    */\n  def log(b: Number): Number =\n    if (b > one)\n      (this, b) match {\n        case (y: ExactNumber, z: ExactNumber) =>\n          ExactNumber.log(y, z) getOrElse doLog(b)\n        case _ =>\n          doLog(b)\n      } else\n      throw CoreException(s\"log(this, b) where b <= 1\")\n\n  /**\n    * Method to determine the natural log of this Number.\n    * The result will be a Number with PureNumber factor.\n    *\n    * @return the natural log of this.\n    */\n  lazy val ln: Field =\n    Number.log(this)\n\n  /**\n    * Method to raise NatLog to the power of this number.\n    * The result will be a Number with NatLog factor.\n    *\n    * @return the e to the power of this.\n    */\n  lazy val exp: Number =\n    Number.exp(this)\n\n  /**\n    * Method to yield the absolute value of this Number.\n    *\n    * @return this if its positive, else - this.\n    */\n  lazy val abs: Number =\n    negateConditional(signum < 0)\n\n  /**\n    * Method to create a new version of this, but with factor f.\n    * NOTE: the result will have the same absolute magnitude as this.\n    * In other words,  in the case where f is not factor, the numerical value of the result's value will be different\n    * from this value.\n    *\n    * @param f the new factor for the result.\n    * @return a Number based on this and factor.\n    */\n  def scale(f: Factor): Number =\n    Number.scale(this, f).specialize\n\n  /**\n    * Perform a fuzzy comparison where we only require p confidence to know that this and other are effectively the same.\n    *\n    * NOTE: This method is used, although it doesn't appear so.\n    *\n    * @param other the Number to be compared with.\n    * @param p     the confidence expressed as a fraction of 1 (0.5 would be a typical value).\n    * @return -1, 0, 1 as usual.\n    */\n  def fuzzyCompare(other: Number, p: Double): Int =\n    FuzzyNumber.fuzzyCompare(this, other, p)\n\n  /**\n    * Method to derive a fuzziness that covers the discrepancy between this and other.\n    *\n    * @param other another Number: the ideal or target value.\n    * @return an optional relative Fuzziness.\n    */\n  def asComparedWith(other: Number): Option[Fuzziness[Double]] =\n    for {\n      q <- doSubtract(other).toNominalDouble\n      r <- other.scale(PureNumber).toNominalDouble\n      p <- AbsoluteFuzz(math.abs(q) / 2, Box).relative(r)\n    } yield p\n\n  /**\n    * Evaluate a dyadic operator on this and other, using either plus, times, ... according to the value of op.\n    * NOTE: this and other must have been aligned by type so that they have the same structure.\n    *\n    * @param other the other operand, a Number.\n    * @param f     the factor to apply to the result.\n    * @param op    the appropriate DyadicOperation.\n    * @return a new Number which is result of applying the appropriate function to the operands this and other.\n    */\n  def composeDyadic(other: Number, f: Factor)(op: DyadicOperation): Option[Number] =\n    doComposeDyadic(other, f)(op.functions)\n\n  /**\n    * Evaluate a monadic operator on this.\n    *\n    * CONSIDER the exact cases don't change the fuzziness at all.\n    * But, if there is already fuzziness, then the monadic function should change it.\n    *\n    * @param f  the factor to apply to the result.\n    * @param op the appropriate MonadicOperation.\n    * @return a new Number which is result of applying the appropriate function to the operand this.\n    */\n  def transformMonadic(f: Factor)(op: MonadicOperation): Option[Number] =\n    Operations.doTransformValueMonadic(nominalValue)(op.functions) flatMap {\n      case v@Right(_) =>\n        Some(make(v, f))\n      case v@Left(Right(_)) =>\n        Some(make(v, f))\n      case v =>\n        make(v, f) match {\n          // NOTE creates a fuzzy number\n          case n: GeneralNumber =>\n            for (t <- toNominalDouble; x <- n.toNominalDouble) yield n.make(Fuzziness.monadicFuzziness(op, t, x, fuzz))\n        }\n    }\n\n  /**\n    * Evaluate a query operator on this.\n    *\n    * @param op the appropriate QueryOperation.\n    * @return a Boolean.\n    */\n  def query[T](op: QueryOperation[T], defaultVal: => T): T =\n    Operations.doQuery(nominalValue, op.getFunctions).getOrElse(defaultVal)\n\n  /**\n    * Make a copy of this Number, given the same degree of fuzziness as the original.\n    * Only the factor will change.\n    * This method does not need to be followed by a call to specialize.\n    *\n    * @param f the factor.\n    * @return a Number.\n    */\n  def make(f: Factor): Number =\n    make(nominalValue, f)\n\n  /**\n    * Make a copy of this Number, given the same degree of fuzziness as the original.\n    * Only the nominalValue will change.\n    * This method should be followed by a call to specialize.\n    *\n    * @param v the nominalValue.\n    * @return a Number.\n    */\n  def make(v: Value): Number =\n    make(v, factor)\n\n  /**\n    * Make a copy of this Number, given the same degree of fuzziness as the original.\n    * Only the nominalValue will change.\n    * This method should be followed by a call to specialize.\n    *\n    * @param v the nominalValue.\n    * @param f Factor.\n    * @return a Number.\n    */\n  def make(v: Int, f: Factor): Number =\n    make(Value.fromInt(v), f)\n\n  /**\n    * Make a copy of this Number, given the same degree of fuzziness as the original.\n    * Only the value will change.\n    * This method should be followed by a call to specialize.\n    *\n    * @param v the value.\n    * @return a Number.\n    */\n  def make(v: Int): Number =\n    make(v, factor)\n\n  /**\n    * Make a copy of this Number, given the same degree of fuzziness as the original.\n    * Only the value and the factor will change.\n    * This method should be followed by a call to specialize.\n    *\n    * NOTE that this method is primarily used by doComposeDyadic\n    *\n    * @param r a Rational.\n    * @param f Factor.\n    * @return a Number.\n    */\n  def make(r: Rational, f: Factor): Number =\n    make(Value.fromRational(r), f)\n\n  /**\n    * Make a copy of this Number, given the same degree of fuzziness as the original.\n    * Only the value will change.\n    * This method should be followed by a call to specialize.\n    *\n    * @param r the value.\n    * @return a Number.\n    */\n  def make(r: Rational): Number =\n    make(r, factor)\n\n  /**\n    * Make a copy of this Number, given the same degree of fuzziness as the original.\n    * Only the value and factor will change.\n    * This method should be followed by a call to specialize.\n    *\n    * TESTME\n    *\n    * @param x the value (a Double).\n    * @param f Factor.\n    * @return a Number.\n    */\n  def make(x: Double, f: Factor): Number =\n    make(Value.fromDouble(Some(x)), f)\n\n  /**\n    * Method to \"normalize\" a number, that's to say make it a PureNumber and also to force\n    * any fuzziness to be absolute.\n    *\n    * @return a new Number with factor of PureNumber but with the same magnitude as this.\n    */\n  lazy val normalize: Field = {\n    def maybeIntValue: Option[Int] = Value.maybeInt(nominalValue)\n\n    val z: Field = factor match {\n      case PureNumber =>\n        Real(this)\n      case r@NthRoot(2) if maybeIntValue.isDefined =>\n        val ro1 = maybeIntValue.filter(_ > 0).flatMap(Rational.squareRoots.get).map(Real(_))\n        val ro2 = maybeIntValue.filter(_ > 0).map(_ => Real(this))\n        val ro3 = maybeIntValue.filter(_ < 0).filter(x => math.abs(x) <= Rational.maxSquare).map(_ => Real(this))\n        ro1 orElse ro2 orElse ro3 getOrElse normalizeRoot(this)\n      case r@NthRoot(_) =>\n        normalizeRoot(this)\n      case Radian =>\n        Real(this) // Number.modulate(this) NOTE: we do modulation at other times\n      case _ =>\n        Real(scale(PureNumber))\n    }\n    z match {\n      case Real(fuzzyNumber: FuzzyNumber) =>\n        Real(fuzzyNumber.normalizeFuzz)\n      case r@Real(_) =>\n        r\n      case x: Complex =>\n        x\n      case x =>\n        throw CoreException(s\"normalize problem: $x\")\n    }\n  }\n\n  /**\n    * Method to ensure that the value is within some factor-specific range.\n    * In particular, Radian=based numbers are modulated to the range 0..2\n    *\n    * @return this or an equivalent Number.\n    */\n  lazy val modulate: Number =\n    Number.modulate(this)\n\n  /**\n    * Return a Number which uses the most restricted type possible.\n    * A Number based on a Double will yield a Number based on a Rational (if the conversion is exact).\n    * A Number based on a Rational will yield a Number based on a BigInt (if there is a unit denominator).\n    * A Number based on a BigInt will yield a Number based on a Int (if it is sufficiently small).\n    *\n    * @return a Number with the same magnitude as this.\n    */\n  //protected\n  lazy val specialize: Number = nominalValue match {\n    // XXX Int case\n    case Right(_) =>\n      this\n    // XXX Rational case\n    case Left(Right(r)) =>\n      Try(r.toInt) match {\n        case Success(b) =>\n          make(b).specialize\n        case _ =>\n          this\n      }\n    case Left(Left(Some(x))) if x.isNaN =>\n      Number.NaN\n    case Left(Left(Some(x))) if x.isInfinity =>\n      Number.Infinity\n    // XXX Double case\n    case d@Left(Left(Some(x))) =>\n      // NOTE: here we attempt to deal with Doubles.\n      // If a double can be represented by a BigDecimal with scale 0, 1, or 2 then we treat it as exact.\n      // Otherwise, we will give it appropriate fuzziness.\n      // In general, if you wish to have more control over this, then define your input using a String.\n      // CONSIDER will this handle numbers correctly which are not close to 1?\n      Rational.createExact(x) match {\n        case Success(r) =>\n          r.toBigDecimal.map(_.scale) match {\n            case Some(0) | Some(1) | Some(2) =>\n              make(r).specialize\n            // CONSIDER in following line adding fuzz only if this Number is exact.\n            case Some(n) =>\n              FuzzyNumber(d, factor, fuzz).addFuzz(AbsoluteFuzz(Fuzziness.toDecimalPower(5, -(n + 1)), Box))\n            case _ =>\n              FuzzyNumber(d, factor, fuzz).addFuzz(Fuzziness.doublePrecision)\n          }\n        case Failure(_) =>\n          FuzzyNumber(d, factor, fuzz).addFuzz(Fuzziness.doublePrecision)\n      }\n    // XXX Invalid case\n    case _ =>\n      this\n  }\n\n  /**\n    * Make a copy of this FuzzyNumber but with additional fuzz given by f.\n    *\n    * @param f the additional fuzz.\n    * @return this but with fuzziness which is the convolution of fuzz and f.\n    */\n  def addFuzz(f: Fuzziness[Double]): Number =\n    FuzzyNumber.addFuzz(this, f)\n\n  /**\n    * Method to align the factors of this and x such that the resulting Numbers (in the tuple) each have the same factor.\n    *\n    * @param x the Number to be aligned with this.\n    * @return a tuple of two Numbers with the same factor.\n    */\n  //protected\n  def alignFactors(x: Number): (Number, Number) = factor match {\n    case PureNumber =>\n      (this, x.scale(factor))\n    case _ =>\n      (scale(x.factor), x)\n  }\n\n  /**\n    * Method to align the types of this and x such that the resulting Numbers (in the tuple) each have the same structure.\n    *\n    * CONSIDER renaming this alignValueTypes\n    *\n    * @param q the Number to be aligned with this.\n    * @return a tuple of two Numbers, the first of which will be the more general type:\n    *         (Invalid vs. Double, Double vs. Rational, Rational vs. Int).\n    */\n  //protected\n  def alignTypes(q: Number): (Number, Number) = q match {\n    case x: GeneralNumber =>\n      nominalValue match {\n        // XXX this is an invalid Number: return a pair of invalid numbers\n        case Left(Left(None)) =>\n          (this, this)\n        // XXX this nominalValue is a real Number: convert x to a Number based on real.\n        case Left(Left(Some(_))) =>\n          x.nominalValue match {\n            // XXX x's nominalValue is invalid: swap the order so the the first element is invalid\n            case Left(Left(None)) =>\n              x.alignTypes(this)\n            // XXX otherwise: return this and x re-cast as a Double\n            case _ =>\n              (this, Number.prepare(x.maybeNominalDouble.map(y => make(y, x.factor, x.fuzz).specialize)))\n          }\n        // XXX this nominalValue is a Rational:\n        case Left(Right(_)) =>\n          x.nominalValue match {\n            // XXX x's nominalValue is a real Number:\n            //  swap the order so that the first element is the real number\n            case Left(Left(_)) =>\n              x.alignTypes(this)\n            // XXX otherwise: return this and x re-cast as a Rational\n            case _ =>\n              (this, x.make(x.maybeNominalRational.getOrElse(Rational.NaN)).specialize)\n          }\n        // XXX this nominalValue is an Int:\n        case Right(_) =>\n          x.nominalValue match {\n            // XXX x's nominalValue is a BigInt, Rational or real Number:\n            //  swap the order so that the first element is the BigInt/Rational/real number\n            case Left(_) =>\n              x.alignTypes(this)\n            // XXX otherwise: return this and x re-cast as an Int\n            case _ =>\n              (this, x.make(x.maybeInt.getOrElse(0), x.factor).specialize)\n          }\n      }\n  }\n\n  /**\n    * An optional Rational that corresponds to the nominalValue of this Number (but ignoring the factor).\n    * A Double nominalValue is not converted to a Rational since, if it could be done exactly, it already would have been.\n    * CONSIDER using query\n    */\n  def maybeNominalRational: Option[Rational] = Value.maybeRational(nominalValue)\n\n  /**\n    * An optional Double that corresponds to the nominalValue of this Number (but ignoring the factor).\n    * If\n    *\n    * @return Some(x) if nominalValue can be converted properly to a Double, otherwise None.\n    */\n  def maybeNominalDouble: Option[Double] =\n    Value.maybeDouble(nominalValue)\n\n  /**\n    * Method to return this ExactNumber as a Real.\n    *\n    * @return Some(Real(this)).\n    */\n  def asReal: Option[Real] = Some(Real(this))\n\n  /**\n    * Ensure that this is consistent with hashCode.\n    *\n    * @param other the other Any.\n    * @return true if this and Any are, logically the same.\n    */\n  override def equals(other: Any): Boolean = other match {\n    case that: GeneralNumber =>\n      (that `canEqual` this) &&\n          nominalValue == that.nominalValue &&\n          factor == that.factor &&\n          fuzz == that.fuzz\n    case _ =>\n      false\n  }\n\n  /**\n    * TESTME\n    *\n    * @return\n    */\n  override def hashCode(): Int = {\n    val state = Seq(nominalValue, factor, fuzz)\n    state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b)\n  }\n\n  /**\n    * Evaluate a dyadic operator on this and other, using the various functions passed in.\n    * NOTE: this and other must have been aligned by type so that they have the same structure.\n    *\n    * @param other     the other operand, a Number.\n    * @param f         the factor to apply to the result.\n    * @param functions the tuple of four conversion functions.\n    * @return a new Number which is result of applying the appropriate function to the operands this and other.\n    */\n  private def doComposeDyadic(other: Number, f: Factor)(functions: DyadicFunctions): Option[Number] = {\n    val vo: Option[Value] = Operations.doComposeValueDyadic(nominalValue, other.nominalValue)(functions)\n    for (v <- vo) yield make(v, f) // CONSIDER what about extra fuzz?\n  }\n\n  /**\n    * Computes the logarithm of the current number to the specified base.\n    *\n    * @param b the base of the logarithm; must be a positive number not equal to 1\n    */\n  private def doLog(b: Number) =\n    (Number.log(this) `divide` Number.log(b)).asNumber.getOrElse(Number.NaN)\n\n  /**\n    * An optional Int that corresponds to the nominalValue of this Number (but ignoring the factor).\n    */\n  private lazy val maybeInt: Option[Int] = Value.maybeInt(nominalValue)\n\n  /**\n    * CONSIDER do we really need this?\n    */\n  private def canEqual(other: Any): Boolean = other.isInstanceOf[GeneralNumber]\n}\n\n/**\n  * The GeneralNumber object provides utility methods for performing various operations on\n  * numbers with particular emphasis on exact, fuzzy, and generalized numeric types.\n  * It aims to handle operations in a flexible way based on the types and factors\n  * associated with numbers.\n  */\nobject GeneralNumber {\n\n  /**\n    * Applies a given mathematical function along with its derivative to the specified number.\n    *\n    * @param f      A function mapping a Double to a Double, representing the main operation to be applied.\n    * @param dfByDx The derivative of the function `f`, mapping a Double to a Double.\n    * @param x      The input number on which the function `f` and its derivative are to be applied.\n    * @return A Try containing the resulting Number if the operation succeeds, or a failure if an error occurs.\n    */\n  def applyFunc(f: Double => Double, dfByDx: Double => Double)(x: Number): Try[Number] = {\n    val op: MonadicOperation = MonadicOperationFunc(f, dfByDx)\n    val no: Option[Number] = Operations.doTransformValueMonadic(x.nominalValue)(op.functions) flatMap {\n      v =>\n        x.make(v, PureNumber) match {\n          case n: GeneralNumber =>\n            for (t <- x.toNominalDouble; z <- n.toNominalDouble) yield n.make(Fuzziness.monadicFuzziness(op, t, z, x.fuzz))\n        }\n    }\n    FP.toTry(no, Failure(CoreException(\"applyFunc: logic error\")))\n  }\n\n  /**\n    * Determines if the given number is equivalent to zero.\n    *\n    * @param x the number to check.\n    * @return true if the number is zero, otherwise false.\n    */\n  def isZero(x: Number): Boolean = x.query(QueryOperationIsZero, false)\n\n  /**\n    * Checks if the given number is infinite.\n    *\n    * @param x the number to be checked for infinity.\n    * @return true if the number is infinite, otherwise false.\n    */\n  def isInfinite(x: Number): Boolean = x.query(QueryOperationIsInfinite, false)\n\n  /**\n    * Performs the addition operation between two numbers, combining them\n    * into a single resultant number as per the mathematical rules defined\n    * by their specific types and factors.\n    *\n    * @param x the first number to be added\n    * @param y the second number to be added\n    * @return the result of adding the two given numbers\n    */\n  def plus(x: Number, y: Number): Number = x match {\n    case ExactNumber(Right(0), PureNumber) =>\n      y\n    case z: GeneralNumber =>\n      if (y == ExactNumber(Right(0), PureNumber)) x\n      else {\n        val (a, b) = z.alignFactors(y)\n        a.factor match {\n          case Logarithmic(_) =>\n            plusAligned(a.scale(PureNumber), b.scale(PureNumber))\n          case NthRoot(_) =>\n            plusAligned(a.scale(PureNumber), b.scale(PureNumber))\n          case _ =>\n            plusAligned(a, b)\n        }\n      }\n  }\n\n  /**\n    * Computes the product of two Number instances recursively.\n    *\n    * @param x the first operand, represented as a Number instance\n    * @param y the second operand, represented as a Number instance\n    * @return the result of multiplying x and y, represented as a Number instance\n    */\n  @tailrec\n  def times(x: Number, y: Number): Number = x match {\n    case Number.zero =>\n      Number.zero\n    case Number.one =>\n      y\n    case a: GeneralNumber =>\n      y match {\n        case Number.zero =>\n          Number.zero\n        case Number.one =>\n          x\n        case n@FuzzyNumber(_, _, _) =>\n          n `doMultiply` x\n        case z: GeneralNumber =>\n          val (p, q) = a.alignTypes(z)\n          (p.factor, q.factor) match {\n            case (Scalar(_), PureNumber) =>\n              doTimes(p, q, p.factor)\n            case (PureNumber, Scalar(_)) =>\n              doTimes(p, q, q.factor)\n            case (f: Logarithmic, g: Logarithmic) if f == g =>\n              prepareWithSpecialize(p.composeDyadic(q, f)(DyadicOperationPlus))\n            case (f: Logarithmic, PureNumber) if q.signum > 0 =>\n              prepareWithSpecialize(p.composeDyadic(q.scale(f), f)(DyadicOperationPlus))\n            case (_: Logarithmic, PureNumber) =>\n              times(p.scale(PureNumber), q)\n            case (NthRoot(m), NthRoot(n)) if m == 2 && n == 2 =>\n              doTimes(p, q, p.factor)\n            case (NthRoot(_), NthRoot(_)) if p == q =>\n              p.make(PureNumber)\n            // NOTE see RQRSpec for discussion of this code.\n            case (r@NthRoot(_), g) =>\n              // NOTE duplicate code below\n              r.multiply(p.nominalValue, q.nominalValue, g) match {\n                case Some((v, f, _)) =>\n                  p.make(v, f)\n                case None =>\n                  times(p.scale(PureNumber), q.scale(PureNumber))\n              }\n            case (g, r@NthRoot(_)) =>\n              g.multiply(p.nominalValue, q.nominalValue, r) match {\n                case Some((v, f, _)) =>\n                  p.make(v, f)\n                case None =>\n                  times(p.scale(PureNumber), q.scale(PureNumber))\n              }\n            case _ =>\n              times(p.scale(PureNumber), q.scale(PureNumber))\n          }\n      }\n  }\n//  def times(x: Number, y: Number): Number = (x, y) match {\n//    case (_, Number.zero) | (Number.zero, _) => Number.zero\n//    case (a, Number.one) => a\n//    case (Number.one, b) => b\n//    case (a: ExactNumber, b: FuzzyNumber) => b doMultiply a\n//    case (a: FuzzyNumber, b) => a doMultiply b\n//    case (a: ExactNumber, b: ExactNumber) => ExactNumber.product(a, b)\n//    case _ => throw CoreException(s\"GeneralNumber.times($x, $y): no match\")\n//  }\n\n//    x match {\n  //    case ExactNumber(Right(0), PureNumber) => Number.zero\n  //    case ExactNumber(Right(1), PureNumber) => y\n//    case a: GeneralNumber =>\n//      y match {\n  //        case ExactNumber(Right(0), PureNumber) => Number.zero\n  //        case ExactNumber(Right(1), PureNumber) => x\n//        case n@FuzzyNumber(_, _, _) => n doMultiply x\n//        case z: GeneralNumber =>\n//          val (p, q) = a.alignTypes(z)\n//          (p.factor, q.factor) match {\n  //            case (Scalar(_), PureNumber) => doTimes(p, q, p.factor)\n  //            case (PureNumber, Scalar(_)) => doTimes(p, q, q.factor)\n  //            case (f: Logarithmic, PureNumber) if q.signum > 0 => prepareWithSpecialize(p.composeDyadic(q.scale(f), f)(DyadicOperationPlus))\n  //            case (_: Logarithmic, PureNumber) => times(p.scale(PureNumber), q)\n  //            case (NthRoot(_), NthRoot(_)) if p == q => p.make(PureNumber)\n//            case (NthRoot(_), NthRoot(_)) => doTimes(p, q.scale(p.factor), p.factor)\n  //            case _ => times(p.scale(PureNumber), q.scale(PureNumber))\n//          }\n//      }\n//  }\n\n  /**\n    * Method to raise an (exact) Number to a power.\n    * NOTE: This method is invoked only by doPower (in ExactNumber).\n    *\n    * TODO: move this into ExactNumber but CAREFULLY!\n    *\n    * CONSIDER: surely that y.scale(PureNumber) might create a fuzzy number, right?\n    *\n    * @param x the base Number (always exact).\n    * @param y the power (may not be exact).\n    * @return x raised to the power of y.\n    */\n  def power(x: Number, y: Number): Number =\n    y.scale(PureNumber).toNominalRational match {\n      case Some(r) =>\n        power(x, r).specialize\n      case None =>\n        // NOTE this is not used, but it doesn't seem to handle fuzziness (of the exponent) properly either.\n        val zo = for (p <- x.toNominalDouble; q <- y.toNominalDouble) yield Number(math.pow(p, q))\n        prepareWithSpecialize(zo)\n    }\n\n  /**\n    * A higher-order function that creates a new `Number` instance\n    * based on a provided prototype `ProtoNumber` and a `Number` instance.\n    *\n    * @return A new `Number` instance created by the `make` method of the provided `Number`,\n    *         using elements of the given `ProtoNumber`.\n    */\n  val protoNumberFunction: Number => ProtoNumber => Number = number => protoNumber => number.make(protoNumber._1, protoNumber._2)\n\n  /**\n    * Method to raise an (exact) Number to a Rational power.\n    * CONSIDER shouldn't this be in ExactNumber? Be careful!\n    *\n    * @param x the base Number.\n    * @param r the power.\n    * @return an exact Number (CHECK is that correct?)\n    */\n  private def power(x: Number, r: Rational): Number =\n    if (r.isZero) Number.one\n    else if (r.isUnity || x == Number.one) x\n    else {\n      x.factor.raise(x.nominalValue, Value.fromRational(r), PureNumber) map protoNumberFunction(x) getOrElse {\n        x.factor match {\n          case Logarithmic(_) =>\n            doTransformValueMonadic(x.nominalValue)(MonadicOperationScale(r).functions) match {\n              case Some(v) =>\n                x.make(v)\n              case None =>\n                throw CoreException(\"power: logic error\")\n            }\n          case Radian =>\n            power(x.scale(PureNumber), r)\n          case PureNumber =>\n            toInts(r) match {\n              case Some((n, d)) =>\n                root(power(x, n), d) match {\n                  case Some(q) =>\n                    q.simplify\n                  case None =>\n                    Number(r.toDouble)\n                }\n              case _ =>\n                throw CoreException(\"rational power cannot be represented as two Ints\")\n            }\n          // TODO we should also handle some situations where r.d is not 1.\n          case NthRoot(n) if r.n == n && r.d == 1 =>\n            x.make(PureNumber)\n          case _ =>\n            power(x.scale(PureNumber), r)\n        }\n      }\n    }\n\n  /**\n    * Method to take the ith root of n.\n    *\n    * @param n the Number whose root is required.\n    * @param i the ordinal of the root (2: square root, etc.).\n    * @return the root.\n    */\n  private def root(n: Number, i: Int): Option[Number] = i match {\n    case 0 =>\n      throw CoreException(s\"root: logic error: cannot take ${i}th root\")\n    case 1 =>\n      Some(n)\n    case 2 =>\n      Some(n.make(SquareRoot))\n    case 3 =>\n      Some(n.make(CubeRoot)) // TESTME\n    case _ =>\n      None\n  }\n\n  /**\n    * Computes the power of a given number raised to an integer exponent.\n    * Positive exponents result in repeated multiplications, while negative\n    * exponents compute the result as the inverse of repeated multiplications.\n    *\n    * @param n the base number to be raised to the power.\n    * @param i the integer exponent.\n    *          A positive value raises the base to the\n    *          power of i, while a negative value computes the inverse of\n    *          raising the base to the absolute value of i.\n    * @return the computed result as a Number.\n    */\n  private def power(n: Number, i: Int) = i match {\n    case x if x > 0 =>\n      LazyList.continually(n).take(x).product\n    case x =>\n      LazyList.continually(Number.inverse(n)).take(-x).product\n  }\n\n  /**\n    * Performs the multiplication operation between two numbers using a given factor.\n    *\n    * @param p      the first number to be multiplied\n    * @param q      the second number to be multiplied\n    * @param factor an instance of Factor representing specific configuration or scaling rules for the operation\n    * @return the result of multiplying the two numbers, represented as a Number\n    */\n  def doTimes(p: Number, q: Number, factor: Factor): Number = {\n\n    p.factor.multiply(p.nominalValue, q.nominalValue, q.factor).map(protoNumberFunction(p)) getOrElse\n        prepareWithSpecialize(p.composeDyadic(q, factor)(DyadicOperationTimes))\n  }\n\n  /**\n    * Aligns two numbers in terms of their types and factors, and performs addition on them.\n    * If one of the numbers is a FuzzyNumber, a specialized addition is delegated to it.\n    * Otherwise, their types are aligned for consistent mathematical operations.\n    *\n    * @param x the first number to be aligned and added\n    * @param y the second number to be aligned and added\n    * @return the result of adding the two aligned numbers\n    */\n  private def plusAligned(x: Number, y: Number): Number = (x, y) match {\n    case (a: GeneralNumber, b: GeneralNumber) =>\n      y match {\n        case n@FuzzyNumber(_, _, _) =>\n          n `doAdd` x\n        case _ =>\n          val (p, q) = a.alignTypes(b)\n          prepareWithSpecialize(p.composeDyadic(q, p.factor)(DyadicOperationPlus))\n      }\n    case _ =>\n      throw CoreException(s\"plusAligned: logic error: cannot add $x and $y\")\n  }\n\n  private def normalizeRoot(x: Number): Field = {\n    val result: Number = x.scale(PureNumber)\n    Real(result)\n  }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/main/scala/com/phasmidsoftware/number/core/numerical/GeneralNumber.scala b/core/src/main/scala/com/phasmidsoftware/number/core/numerical/GeneralNumber.scala
--- a/core/src/main/scala/com/phasmidsoftware/number/core/numerical/GeneralNumber.scala	(revision 79a04e6d8be0ac7d5aa1e9f007844203f4b8c4fe)
+++ b/core/src/main/scala/com/phasmidsoftware/number/core/numerical/GeneralNumber.scala	(date 1770437770646)
@@ -490,14 +490,11 @@
     // XXX Int case
     case Right(_) =>
       this
-    // XXX Rational case
+    // XXX Rational cases
+    case Left(Right(Rational(x,Rational.bigOne))) =>
+      make(x)
     case Left(Right(r)) =>
-      Try(r.toInt) match {
-        case Success(b) =>
-          make(b).specialize
-        case _ =>
-          this
-      }
+      this
     case Left(Left(Some(x))) if x.isNaN =>
       Number.NaN
     case Left(Left(Some(x))) if x.isInfinity =>
