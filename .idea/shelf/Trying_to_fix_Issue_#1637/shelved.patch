Index: expression/src/main/scala/com/phasmidsoftware/number/expression/expr/ExpressionFunction.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/expression/src/main/scala/com/phasmidsoftware/number/expression/expr/ExpressionFunction.scala b/expression/src/main/scala/com/phasmidsoftware/number/expression/expr/ExpressionFunction.scala
--- a/expression/src/main/scala/com/phasmidsoftware/number/expression/expr/ExpressionFunction.scala	(revision ffbcb0368690ef2ffedcd387a2c3bf852ba13b5f)
+++ b/expression/src/main/scala/com/phasmidsoftware/number/expression/expr/ExpressionFunction.scala	(date 1769001544381)
@@ -107,8 +107,11 @@
     * @param context the `Context` within which the evaluation is performed.
     * @return an `Option[Eager]` containing the result of the evaluation if successful, or `None` otherwise.
     */
-  def evaluate(a: Expression)(context: Context): Option[Eager] =
-    context.qualifyingEagerValue(a.evaluateAsIs flatMap applyExact)
+  def evaluate(a: Expression)(context: Context): Option[Eager] = {
+    val maybeEager1 = a.evaluateAsIs flatMap applyExact
+    if (maybeEager1.isEmpty) println(s"ExpressionMonoFunction: $this failed to evaluate $a")
+    context.qualifyingEagerValue(maybeEager1)
+  }
 //    context.qualifyingEagerValue(a.evaluate(paramContext(context)).map(f))
 
   /**
@@ -128,8 +131,11 @@
     * @return the result of f(x).
     */
   def apply(x: Eager): Eager =
-    if (x.isExact)
-      applyExact(x).getOrElse(f(x))
+    if (x.isExact) {
+      val maybeEager = applyExact(x)
+      if (maybeEager.isEmpty) println(s"ExpressionMonoFunction: $this failed to evaluate $x")
+      maybeEager.getOrElse(f(x))
+    }
     else
       f(x)
 
@@ -285,6 +291,8 @@
       y <- b.evaluate(cRight)
       z <- applyExact((x, y))
     } yield z
+    if (eo.isEmpty)
+      println(s"ExpressionBiFunction: $this failed to evaluate ${a.toString}, ${b.toString}  in context $context")
     context.qualifyingEagerValue(eo)
   }
 
@@ -315,13 +323,13 @@
     * @return an `Option[Valuable]` containing the result of the exact binary operation on the evaluated results
     *         of `x` and `y`, or `None` if any step in the process fails.
     */
-  def doEvaluate(x: Expression, y: Expression)(context: Context): Option[Eager] =
-    for
-      a <- x.evaluate(leftContext(context))
-      f <- a.maybeFactor(AnyContext)
-      b <- y.evaluate(rightContext(f)(RestrictedContext(f)))
-      z <- applyExact(a, b)
-    yield z
+//  def doEvaluate(x: Expression, y: Expression)(context: Context): Option[Eager] =
+//    for
+//      a <- x.evaluate(leftContext(context))
+//      f <- a.maybeFactor(AnyContext)
+//      b <- y.evaluate(rightContext(f)(RestrictedContext(f)))
+//      z <- applyExact(a, b)
+//    yield z
 
   /**
     * Evaluates two expressions as-is (without any simplification or conversion) and applies the function `f`
@@ -844,7 +852,7 @@
     case (x: Scalable[Eager] @unchecked, y: Q) =>
       Some(x * y.toRational)
     case _ =>
-//      println(s"Product:applyExact: a = $a, b = $b resulted in None")
+      println(s"Product:applyExact: a = $a, b = $b resulted in None")
       None
   }
 }
@@ -919,15 +927,21 @@
   def applyExact(a: Eager, b: Eager): Option[Eager] = (a, b) match {
     case (Eager.one, _) =>
       Some(Eager.one)
-    case (_, eager.Real.infinity | RationalNumber.infinity) =>
-      Some(b)
+      // TODO restore this when we have a better understanding of the behavior of the power function.
+//    case (_, eager.Real.infinity | RationalNumber.infinity) =>
+//      Some(b)
     case (x: eager.InversePower, y: eager.ExactNumber) =>
       x.pow(y).asInstanceOf[Option[Eager]]
-    case (x: CanPower[eager.Scalar] @unchecked, y: Q) if x.isExact && y.isExact =>
+    case (x: CanPower[eager.Structure] @unchecked, y: Q) if x.isExact && y.isExact =>
+      val z = x.pow(RationalNumber(y.toRational))
+      println(s"Power:applyExact: a = $a, b = $b resulted in $z")
       for {
         f <- y.maybeFactor(AnyContext) if f == PureNumber
-        result <- x.pow(RationalNumber(y.toRational)) if result.isExact
+        result <- x.pow(RationalNumber(y.toRational))
+        _ = println(s"result=$result") //if result.isExact
       } yield result
+    case (x: eager.Number, RationalNumber(y,_)) if y.invert.isWhole =>
+      Some(eager.InversePower(y.invert.toInt, x))
     case _ =>
       None // TESTME
   }
