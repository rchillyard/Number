Index: core/src/main/scala/com/phasmidsoftware/number/core/numerical/BaseComplex.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (c) 2023. Phasmid Software\n */\n\npackage com.phasmidsoftware.number.core.numerical\n\nimport com.phasmidsoftware.number.core.inner.*\nimport com.phasmidsoftware.number.core.misc.FP.*\nimport com.phasmidsoftware.number.core.numerical.BaseComplex.narrow\nimport com.phasmidsoftware.number.core.numerical.Complex.{convertToCartesian, convertToPolar}\nimport com.phasmidsoftware.number.core.numerical.Field.convertToNumber\nimport com.phasmidsoftware.number.core.numerical.Number.{negate, two, zero, zeroR}\n\n/**\n  * Abstract base class which implements Complex.\n  *\n  * @param real the real component.\n  * @param imag the imaginary component.\n  */\nabstract class BaseComplex(val real: Number, val imag: Number) extends Complex {\n\n  /**\n    * Method to return this Field as a Complex.\n    * If this is a Real number x, return ComplexPolar(x) otherwise, return this.\n    *\n    * @return a Complex.\n    */\n  lazy val asComplex: Complex = this\n\n  /**\n    * Method to compare this BaseComplex with that Field.\n    * Required by implementing Ordered[Field].\n    * NOTE if the difference is a Complex number, we try to do fuzzy comparison (with confidence of 0.5).\n    *\n    * TODO Complex should not implement compare (that's to say Field should not extend Ordering).\n    *\n    * @param that (a Field).\n    * @return the comparison.\n    */\n  def compare(that: Field): Int = that match {\n    case y: Complex =>\n      val difference: Field = this + -y\n      if (difference.isZero) 0\n      else difference match {\n        case c: Complex if c.modulus.isProbablyZero() =>\n          0\n        case c: Complex if c.isImaginary =>\n          c.modulus.signum\n        case c =>\n          c.signum\n      }\n    case Real(y) =>\n      compare(ComplexCartesian(y))\n  }\n\n  /**\n    * Method to determine if this Field is equivalent to another Field (x).\n    *\n    * @param x the other field.\n    * @return true if they are the same, otherwise false.\n    */\n  def isSame(x: Numerical): Boolean = (this, x) match {\n    case (z, Real(n)) =>\n      z `isSame` n.asComplex\n    case (c1@ComplexCartesian(_, _), c2@ComplexPolar(_, _, _)) =>\n      c2.isSame(c1)\n    case (c1@ComplexPolar(_, _, _), c2@ComplexCartesian(_, _)) =>\n      c1.isSame(convertToPolar(c2))\n    case (c1, c2: Complex) =>\n      (c1 `subtract` c2).isZero\n    case (z, x: Number) =>\n      z `isSame` Real(x)\n    case _ =>\n      false\n  }\n\n  /**\n    * Determines if this complex number has a modulus of unity (magnitude of one).\n    * This is true if the modulus of the complex number, when subtracted by one, equals zero.\n    * TESTME\n    *\n    * @return true if the modulus of this complex number is unity (1), otherwise false.\n    */\n  lazy val isUnity: Boolean =\n    modulus.doSubtract(Number.one).isZero\n\n  /**\n    * Add x to this Complex and return the result.\n    *\n    * @param x the addend.\n    * @return the sum.\n    */\n  def add(x: Field): Field =\n    sum(narrow(x, polar = false))\n\n  /**\n    * Method to add this to the given parameter (a Cartesian).\n    *\n    * @param addend the complex addend.\n    * @return the sum of this and addend.\n    */\n  def sum(addend: Complex): Complex = this match {\n    case ComplexCartesian(_, _) => doAdd(addend)\n    case ComplexPolar(_, _, _) => narrow(this, polar = false) `doAdd` addend\n  }\n\n  /**\n    * Divide this Complex by x and return the result.\n    * See * and invert for more detail.\n    *\n    * @param x the divisor.\n    * @return the quotient.\n    */\n  def divide(x: Field): Field =\n    this `multiply` x.invert\n\n  /**\n    * Multiply this Complex by x and return the result.\n    *\n    * * @param x the multiplicand.\n    * * @return the product.\n    */\n  def multiply(x: Field): Field = x match {\n    case Real(n) => numberProduct(n)\n    case c@BaseComplex(_, _) => product(c)\n  }\n\n  /**\n    * Method to multiply this by the given parameter (a Polar).\n    *\n    * @param multiplicand the complex multiplicand.\n    * @return the product of this and multiplicand.\n    */\n  def product(multiplicand: Complex): Complex = (this, multiplicand) match {\n    case (ComplexPolar(_, _, _), ComplexPolar(_, _, _)) =>\n      doMultiply(multiplicand)\n    case (ComplexPolar(_, _, _), ComplexCartesian(_, _)) =>\n      narrow(this, polar = false) `doMultiply` multiplicand\n    case (ComplexCartesian(_, _), ComplexCartesian(_, _)) =>\n      doMultiply(multiplicand)\n    case (ComplexCartesian(_, _), ComplexPolar(_, _, _)) =>\n      narrow(this, polar = true) `doMultiply` multiplicand\n    case _ =>\n      throw ComplexException(s\"BaseComplex: product: $this, $multiplicand\")\n  }\n\n  /**\n    * Computes the result of raising this number (field element) to the given power `n`.\n    *\n    * @param n The exponent as a `Number` to which this field element will be raised.\n    *          Can represent integer, rational, or other numerical values.\n    * @return A new `Field` instance that is the result of performing the power operation.\n    */\n  def power(n: Number): Complex = this match {\n    case ComplexPolar(re, im, w) if n.isRational =>\n      doRationalPowerForComplexPolar(n, re, im, w)\n    case ComplexPolar(re, im, w) =>\n      ComplexPolar(re.doPower(n), im.doMultiply(n), w)\n    case c@ComplexCartesian(_, _) => n match {\n      case Number.one =>\n        c\n      case Number.negOne =>\n        c.invert\n      case Number.two =>\n        c.square\n      case _ =>\n        convertToPolar(c).power(n).asInstanceOf[Complex] // CONSIDER try to improve upon this\n    }\n  }\n\n  /**\n    * Raise this Complex to the power p.\n    *\n    * @param p a Number.\n    * @return this Number raised to power p.\n    */\n  def power(p: Field): Field = (this, p) match {\n    case (_, Constants.zero) =>\n      Constants.one\n    case (_, Constants.one) =>\n      this\n    case (_, Constants.minusOne) =>\n      invert\n    case (_, Constants.two) =>\n      square\n    case (c, p) if c.compare(Constants.e) == 0 && isIPi(p) =>\n      Constants.minusOne // XXX Euler's identity\n    case (ComplexCartesian(_, Number.zeroR), x) =>\n      power(x)\n    case _ =>\n      throw CoreException(s\"power not supported for: $this ∧ $p\")\n  }\n\n  /**\n    * Method to compute the square of the modulus (magnitude) of this complex number.\n    *\n    * @return the square of the modulus as a Number.\n    */\n  def modulusSquared: Number\n\n  /**\n    * Yields the inverse of this Complex.\n    *\n    * @return the result of invoking power(-1).\n    */\n  def invert: Field\n\n  /**\n    * Method to determine if this Field is actually a real (or imaginary) Number (i.e. not complex).\n    * NOTE: to force this as a Number, use convertToNumber in the companion Object.\n    *\n    * @return a Some(x) if this is a Number; otherwise return None.\n    */\n  lazy val asNumber: Option[Number] =\n    this match {\n      case ComplexCartesian(x, y) if y.isProbablyZero() =>\n        Some(x)\n      case ComplexCartesian(x, y) if x.isProbablyZero() =>\n        Some((y `doMultiply` y).makeNegative.make(SquareRoot))\n      case ComplexPolar(r, theta, _) if theta.isProbablyZero() =>\n        Some(r)\n      // CONSIDER allowing approximately pi\n      case ComplexPolar(r, theta, _) if theta == Number.pi =>\n        Some(r.makeNegative)\n      case p@ComplexPolar(_, theta, _) if (theta `doMultiply` 2).abs == Number.pi =>\n        convertToCartesian(p).asNumber\n      case _ =>\n        None\n    }\n\n  /**\n    * Method to determine the conjugate of this Complex number.\n    *\n    * @return the conjugate of this Complex.\n    */\n  lazy val conjugate: Complex =\n    make(real, imag.makeNegative)\n\n  /**\n    * Instance method to make a Complex number from a real and an imaginary part.\n    *\n    * @param a the real part.\n    * @param b the imaginary part.\n    * @return a Complex number, either ComplexCartesian or ComplexPolar\n    */\n  def make(a: Number, b: Number): BaseComplex\n\n  /**\n    * Computes the sine of this complex number.\n    * The result is calculated in the context of complex numbers, applying the necessary\n    * formulas for the sine function on complex inputs.\n    *\n    * @return the sine of this complex number as an instance of `Field`.\n    */\n  lazy val sin: Field = ??? // TODO implement me\n\n  /**\n    * Computes the cosine of this field element, interpreted in the context of a complex number.\n    * The cosine operation is defined mathematically and extended to work with complex values,\n    * leveraging the properties of exponential functions in the complex plane.\n    *\n    * @return a `Field` representing the cosine of this field element.\n    */\n  lazy val cos: Field = ??? // TODO implement me\n\n  /**\n    * Computes the tangent of this complex number.\n    *\n    * @return The tangent of this complex number as a `Field`.\n    */\n  lazy val tan: Field = ??? // TODO implement me\n\n  /**\n    * Computes the arc tangent of the given real number `y` in the context of this `Field`.\n    *\n    * @param y the real number whose arc tangent is to be computed.\n    * @return a `Field` representing the arc tangent of the input.\n    */\n  def atan(y: Real): Field = ??? // TODO implement me\n\n  /**\n    * Computes the natural logarithm of this Field.\n    * For a real number x, this is equivalent to the logarithm base e: ln(x).\n    * For a complex number, this computes the multi-valued complex logarithm.\n    *\n    * @return the natural logarithm of this Field as a Field.\n    */\n  def ln: Field\n\n  /**\n    * Computes the exponential of this complex number.\n    *\n    * @return the exponential of this Field as a new Field instance.\n    */\n  lazy val exp: Field = ??? // TODO implement me\n\n  /**\n    * Method to render the imaginary value as a String.\n    *\n    * @return a String representing the imaginary value.\n    */\n  protected def showImaginary(polar: Boolean, branch: Int = 0, n: Int = 1): String = (imag, branch, n) match {\n    case (Number.zero, 0, 1) | (Number.zeroR, 0, 1) =>\n      \"0\"\n    case (x, 0, 1) => // TESTME\n      // CONSIDER Try to merge this code with the following case\n      val sign = (x, polar) match {\n        case (Number.zero, true) =>\n          \"\"\n        case (_, true) if x.isPositive =>\n          \"\"\n        case _ if x.isPositive =>\n          \"+\"\n        case _ =>\n          \"-\"\n      }\n      s\"${sign}i${x.abs.render}\"\n    case (Number.zeroR, z, n) =>\n      val x = Number.zeroR.doAdd(Number.twoPi.doMultiply(z).doDivide(n))\n      val sign = (x, polar) match {\n        case (Number.zero, true) =>\n          \"\"\n        case (_, true) =>\n          \"\"\n        case _ if x.isPositive =>\n          \"+\"\n        case _ =>\n          \"-\"\n      }\n      s\"${sign}i${x.abs.render}\"\n    case _ =>\n      throw ComplexException(s\"showImaginary: polar = $polar, branch = $branch, n = $n\")\n  }\n\n  /**\n    * Determines if the given `Field` is a complex number that represents\n    * an imaginary number with a modulus equal to π.\n    *\n    * @param p the `Field` object to evaluate, which can be a complex number or any other type.\n    *          If it is a complex, the method checks if it is purely imaginary and its modulus is π.\n    * @return true if the `Field` is a purely imaginary complex number with modulus π, false otherwise.\n    */\n  private def isIPi(p: Field) = p match {\n    case complex: Complex =>\n      complex.isImaginary && complex.modulus == Number.pi\n    case _ =>\n      false\n  }\n\n  /**\n    * Method to compute the result of raising a complex number, represented in polar form,\n    * to a rational power. This involves converting the given power to a rational, computing\n    * the radial component raised to the power, and resolving the appropriate branch for the\n    * result based on the total number of branches `w`.\n    *\n    * @param n  the power to which the complex number is raised.\n    * @param re the radial component (magnitude) of the complex number in polar form.\n    * @param im the angular component (argument) of the complex number in polar form.\n    * @param w  the number of branches to consider for the result, typically used for\n    *           handling multi-valued functions like roots in the complex plane.\n    */\n  private def doRationalPowerForComplexPolar(n: Number, re: Number, im: Number, w: Int) = recover(\n    for {\n      z <- n.toNominalRational\n      r = re `power` n\n      branches <- (z.invert * w).maybeInt\n    } yield ComplexPolar(r, im.doMultiple(z), branches),\n    ComplexException(\"logic error: power\")\n  )\n}\n\n/**\n  * Companion object to BaseComplex.\n  */\nobject BaseComplex {\n\n  /**\n    * Method used by pattern-matching to yield the real and imaginary parts of a BaseComplex.\n    *\n    * NOTE this is dangerous.\n    *\n    * @param complex a BaseComplex.\n    * @return an optional tuple of two Numbers (real, imag).\n    */\n  def unapply(complex: BaseComplex): Option[(Number, Number)] =\n    Some(complex.real, complex.imag)\n\n  /**\n    * Method to take a field and narrow it to a BaseComplex.\n    *\n    * @param x     a Field.\n    * @param polar whether we want a polar result or a cartesian result.\n    * @return a BaseComplex.\n    */\n  def narrow(x: Field, polar: Boolean): Complex = x match {\n    case c@ComplexCartesian(_, _) =>\n      if (polar) convertToPolar(c) else c\n    case c@ComplexPolar(_, _, _) =>\n      if (!polar) convertToCartesian(c) else c\n    case Real(x) =>\n      ComplexCartesian(x, Number.zero)\n    case _ =>\n      throw CoreException(s\"BaseComplex: narrow: x can't be matched: $x\")\n  }\n}\n\n/**\n  * Case class to represent a Cartesian complex object.\n  *\n  * @param x the real part.\n  * @param y the imaginary part.\n  */\ncase class ComplexCartesian(x: Number, y: Number) extends BaseComplex(x, y) {\n\n  /**\n    * Method to determine if this NumberLike object is exact.\n    * For instance, Number.pi is exact, although if you converted it into a PureNumber, it would no longer be exact.\n    *\n    * @return true if this NumberLike object is exact in the context of No factor, else false.\n    */\n  lazy val isExact: Boolean =\n    x.isExact && y.isExact\n\n  /**\n    * Method to determine the modulus of this Complex number.\n    *\n    * CONSIDER implementing real in the Complex trait (not just BaseComplex).\n    *\n    * @return the modulus of this Complex.\n    */\n  lazy val modulus: Number =\n    if (isReal) real else if (isImaginary) imag else convertToPolar(this).asInstanceOf[BaseComplex].real\n\n  /**\n    * Method to determine if this Complex is real-valued (i.e., the point lies on the real axis).\n    *\n    * @return true is y is zero.\n    */\n  lazy val isReal: Boolean =\n    y.isZero\n\n  /**\n    * Method to determine if this Complex is imaginary-valued (i.e. the point lies on the imaginary axis).\n    *\n    * @return true if the real part is zero (argument is a multiple of pi/2).\n    */\n  lazy val isImaginary: Boolean =\n    x.isZero\n\n  /**\n    * Change the sign of this Number.\n    */\n  lazy val unary_- : Field =\n    make(Number.negate(real), Number.negate(imag))\n\n  /**\n    *\n    * @return a Number (in radians).\n    */\n  lazy val argument: Number =\n    convertToPolar(this).argument\n\n  /**\n    * Rotate this Complex number by pi/2 counter-clockwise (i.e. multiply by i).\n    * TESTME\n    *\n    * @return the value of this * i.\n    */\n  lazy val rotate: BaseComplex =\n    ComplexCartesian(imag.makeNegative, real)\n\n  /**\n    * Method to multiply this BaseComplex by a Number.\n    *\n    * @param n the Number.\n    * @return a Complex with the same argument as this but a different magnitude.\n    */\n  def numberProduct(n: Number): Complex =\n    if (n.isImaginary)\n      doMultiply(ComplexCartesian.fromImaginary(n))\n    else\n      make(x `doMultiply` n, y `doMultiply` n)\n\n  /**\n    * Add two Cartesian Complex numbers.\n    *\n    * @param complex the addend.\n    * @return the sum.\n    */\n  def doMultiply(complex: Complex): Complex = complex match {\n    case ComplexCartesian(a, b) =>\n      val real: Number = (a `doMultiply` x) `doAdd` (b `doMultiply` y `doMultiply` Number.negOne)\n      val imag: Number = (a `doMultiply` y) `doAdd` (b `doMultiply` x)\n      ComplexCartesian(real, imag)\n    case ComplexPolar(_, _, _) =>\n      throw ComplexException(\"logic error: ComplexCartesian.doAdd\")\n  }\n\n  /**\n    * Method to determine if this complex number is probably zero (with probability of 1/2).\n    * TESTME\n    *\n    * @return true if the magnitude of this Field is zero.\n    */\n  lazy val isZero: Boolean =\n    x.isProbablyZero() && y.isProbablyZero()\n\n  /**\n    * Determines if either the real or imaginary part of this Complex number is infinite.\n    * TESTME\n    *\n    * @return true if the real part or the imaginary part is infinite; false otherwise.\n    */\n  lazy val isInfinite: Boolean =\n    x.isInfinite || y.isInfinite\n\n  /**\n    * Computes the natural logarithm of this Field.\n    * For a real number x, this is equivalent to the logarithm base e: ln(x).\n    * For a complex number, this computes the multi-valued complex logarithm.\n    *\n    * @return the natural logarithm of this Field as a Field.\n    */\n  lazy val ln: Field = throw ComplexException(\"not implemented: ComplexCartesian.ln\")\n\n  /**\n    * TESTME\n    *\n    * @return a Field which is in canonical form.\n    */\n  lazy val normalize: Field =\n    ComplexCartesian(convertToNumber(x.normalize), convertToNumber(y.normalize)) match {\n      case ComplexCartesian(real, imag) if imag.isZero =>\n        Real(real)\n      case c =>\n        c\n    }\n\n  /**\n    * Action to simplifyAndEvaluate this Expression and render it as a String,\n    * that is to say we eagerly evaluate this Expression as a String.\n    *\n    * @return a String representing the value of this expression.\n    */\n  lazy val render: String =\n    if (isReal)\n      x.render\n    else if (isImaginary)\n      s\"i${y.render}\"\n    else\n      s\"\"\"(${x.render}${showImaginary(polar = false)})\"\"\"\n\n  /**\n    * Add two Cartesian Complex numbers.\n    *\n    * @param complex the addend.\n    * @return the sum.\n    */\n  def doAdd(complex: Complex): BaseComplex = complex match {\n    case ComplexCartesian(a, b) =>\n      ComplexCartesian(x `doAdd` a, y `doAdd` b)\n    case c@ComplexPolar(_, _, _) =>\n      doAdd(convertToCartesian(c))\n  }\n\n  /**\n    * Computes the square of a complex number represented in Cartesian form.\n    * The result is a new `ComplexCartesian` value obtained by applying the formula:\n    * (x∧2 - y∧2, 2xy), where `x` and `y` are the real and imaginary parts respectively.\n    *\n    * @return a `ComplexCartesian` instance representing the square of the original complex number.\n    */\n  lazy val square: ComplexCartesian =\n    ComplexCartesian(x.doPower(Number.two) `doSubtract` y.doPower(Number.two), x `doMultiply` y `doMultiply` Number.two)\n\n  /**\n    * Yields the inverse of this Complex.\n    *\n    * @return the result of invoking power(-1).\n    */\n  lazy val invert: Complex =\n    conjugate.asInstanceOf[ComplexCartesian] `scale` modulusSquared.getInverse\n\n  /**\n    * Calculates the square of the modulus of the complex number represented by this instance.\n    * The modulus squared is computed as the sum of the squares of the real and imaginary components.\n    *\n    * @return the squared modulus of the complex number.\n    */\n  lazy val modulusSquared: Number =\n    imag.doPower(two) `doAdd` real.doPower(two)\n\n  /**\n    * Method to scale this Cartesian Complex number by a factor.\n    *\n    * TODO implement for more imaginary factors.\n    *\n    * @param x the factor (a Number).\n    * @return this scaled by x.\n    */\n  private def scale(x: Number) = x match {\n    case Number.i =>\n      make(negate(imag), real)\n    case _ =>\n      make(real `doMultiply` x, imag `doMultiply` x)\n  }\n\n  /**\n    * Method to make a BaseComplex from a pair of numbers (treated as the real and imaginary parts of a\n    * Cartesian Complex number).\n    *\n    * @param a the real part.\n    * @param b the imaginary part.\n    * @return a Complex number, either ComplexCartesian or ComplexPolar\n    */\n  def make(a: Number, b: Number): BaseComplex =\n    ComplexCartesian(a, b)\n\n  /**\n    * Method to return this Complex as a Real, if possible.\n    * If this is a Real number x, return Some(x) otherwise, return None.\n    *\n    * @return an Option[Real].\n    */\n  def asReal: Option[Real] =\n    if (isReal) Some(Real(x)) else None\n\n  /**\n    * Determine the \"sign\" of this field.\n    * For a real-valued quantity (Real or Number), we try to determine if it is to the right, left, or at the origin.\n    * For a complex number, we get the signum of the real part.\n    *\n    * @return +1 if to the right of the origin, -1 if to the left, 0 if at the origin.\n    */\n  lazy val signum: Int =\n    x.signum\n\n  /**\n    * Computes the absolute value of this complex number, represented in Cartesian coordinates.\n    * The result is a new complex number with both the real and imaginary components replaced\n    * by their respective absolute values.\n    *\n    * NOTE WARNING this is very arbitrary. Maybe abs should not be in NumberLike.\n    *\n    * @return a Numerical instance that is the absolute value of this complex number.\n    */\n  lazy val abs: Numerical = ComplexCartesian(x.abs, y.abs)\n}\n\n/**\n  * Companion object to ComplexCartesian.\n  */\nobject ComplexCartesian {\n\n  /**\n    * Method to create a ComplexCartesian from two Int parameters.\n    *\n    * @param x the real part.\n    * @param y the imaginary part.\n    * @return a ComplexCartesian made of up x and y.\n    */\n  def apply(x: Int, y: Int): ComplexCartesian =\n    ComplexCartesian(Number(x), Number(y))\n\n  /**\n    * Method to create a real-valued ComplexCartesian.\n    *\n    * @param x the real value.\n    * @return a ComplexCartesian with values x and 0.\n    */\n  def apply(x: Number): ComplexCartesian =\n    ComplexCartesian(x, 0)\n\n  /**\n    * Constructs a complex number from an imaginary part.\n    *\n    * @param number the imaginary part represented as a Number instance. It must meet specific\n    *               criteria (e.g., be associated with SquareRoot and have a negative value).\n    *\n    * @return a Complex number in Cartesian form with a real part of zero and the provided imaginary part.\n    * @note Throws ComplexException if the given number does not satisfy the required logic.\n    */\n  def fromImaginary(number: Number): Complex = number match {\n    case Number(v, SquareRoot) if Value.signum(v) < 0 =>\n      ComplexCartesian(zero, Number.create(Value.abs(v)))\n    case _ =>\n      throw ComplexException(s\"fromImaginary: logic error for $number\")\n  }\n}\n\n/**\n  * Class to represent a family of Complex numbers in polar form.\n  * An instance of this class actually represents n different complex numbers.\n  *\n  * @param r     the real part (the magnitude) of the number(s).\n  * @param theta the imaginary part (the angle) of the 0th branch of the number.\n  * @param n     the number of \"branches\" in this set of complex numbers.\n  */\ncase class ComplexPolar(r: Number, theta: Number, n: Int = 1) extends BaseComplex(r, theta) {\n  /**\n    * Method to determine if this NumberLike object is exact.\n    * For instance, Number.pi is exact, although if you converted it into a PureNumber, it would no longer be exact.\n    *\n    * @return true if this NumberLike object is exact in the context of No factor, else false.\n    */\n  lazy val isExact: Boolean =\n    r.isExact && theta.isExact\n\n  require(theta.factor == Radian, \"polar theta is not in radians\")\n\n  //  require(!r.isZero, \"polar radius is zero\")\n  if (r.isZero)\n    System.err.println(s\"Warning: Polar r is zero: $this\") // TODO make this a requirement\n\n  /**\n    * Method to determine if this Complex is imaginary-valued (i.e., the point lies on the imaginary axis).\n    *\n    * @return true if the real part is zero (argument is a multiple of pi/2).\n    */\n  lazy val isImaginary: Boolean =\n    rotate.isReal\n\n  /**\n    * Rotate this Complex number by pi/2 counter-clockwise (i.e., multiply by i).\n    *\n    * @return the value of this * i.\n    */\n  lazy val rotate: ComplexPolar =\n    rotate(Number.piBy2)\n\n  /**\n    * Method to determine the modulus of this Complex number.\n    *\n    * @return the modulus of this Complex.\n    */\n  lazy val modulus: Number = r\n\n  /**\n    *\n    * @return a Number (in radians).\n    */\n  lazy val argument: Number = theta\n\n  /**\n    * Computes the square of the modulus (magnitude) of this ComplexPolar instance.\n    *\n    * @return the squared modulus as a Number.\n    */\n  lazy val modulusSquared: Number = r `power` two\n\n  /**\n    * Computes the square of this ComplexPolar instance by doubling its argument (angle).\n    * The operation preserves the modulus while doubling the angle in polar representation.\n    *\n    * @return a new Field representing the squared value of the ComplexPolar instance.\n    */\n  lazy val square: Field = copy(r = r `power` 2, theta = theta `doMultiple` 2)\n\n  /**\n    * Yields the inverse of this Complex.\n    * TESTME\n    *\n    * @return the result of invoking power(-1).\n    */\n  lazy val invert: Field =\n    ComplexPolar(real.getInverse, imag.makeNegative)\n\n  /**\n    * Change the sign of this Number.\n    */\n  def unary_- : Field =\n    rotate(Number.pi)\n\n  /**\n    * Rotate this Complex number by phi counter-clockwise.\n    *\n    * @return the value of this, rotated by phi.\n    */\n  def rotate(phi: Number): ComplexPolar =\n    ComplexPolar(real, imag `doAdd` phi)\n\n  /**\n    * Computes the natural logarithm of this Field.\n    * For a real number x, this is equivalent to the logarithm base e: ln(x).\n    * For a complex number, this computes the multi-valued complex logarithm.\n    *\n    * @return the natural logarithm of this Field as a Field.\n    */\n  lazy val ln: Field =\n    r.ln match {\n      case Real(n) =>\n        ComplexCartesian(n, theta)\n      case _ =>\n        throw ComplexException(\"logic error: ComplexPolar.ln\")\n    }\n\n  /**\n    * Multiplies this ComplexPolar instance with a given Number and returns the result as a Complex.\n    * If the given Number is imaginary, the operation involves converting this ComplexPolar to its Cartesian form\n    * and applying a rotation. Otherwise, the product is computed in polar form using the magnitude and angle.\n    *\n    * @param n the Number to multiply with. This can be a real or imaginary number.\n    * @return the product as a Complex.\n    */\n  def numberProduct(n: Number): Complex = {\n    // TODO this first option currently works only for i, not for multiples of i.\n    if (n.isImaginary) convertToCartesian(this).rotate\n    else make(r `doMultiply` n, theta)\n  }\n\n  /**\n    * Method to determine if this ComplexPolar is zero.\n    *\n    * TESTME\n    *\n    * @return true if the magnitude of this Field is zero.\n    */\n  def isZero: Boolean =\n    r.isZero\n\n  /**\n    * Determines if the magnitude of this Complex field is infinite.\n    *\n    * @return true if the magnitude of this Complex field is infinite, otherwise false.\n    */\n  def isInfinite: Boolean =\n    r.isInfinite\n\n  /**\n    * Normalize a ComplexField based on specific rules of theta modulation and context.\n    * - If theta is 0 and n is 1, return the real part of `r`.\n    * - If theta is 1 (normalized as Radian) and n is 1, return the negation of the real part of `r`.\n    * - Otherwise, return a ComplexPolar representation of the field.\n    *\n    * @return a Field that represents the normalized form of the Instance.\n    */\n  def normalize: Field = (r, Number.modulate(theta), n) match {\n    case (z, ExactNumber(Value(0), Radian), 1) =>\n      Real(z)\n    case (z, ExactNumber(Value(1), Radian), 1) =>\n      -z\n    case (z, t, n) =>\n      ComplexPolar(z, t, n)\n  }\n\n  /**\n    * Action to simplifyAndEvaluate this Expression and render it as a String,\n    * that is to say we eagerly evaluate this Expression as a String.\n    * TESTME (partial)\n    *\n    * NOTE that some of these special cases that are handled here should be eliminated by a prior call to normalize.\n    *\n    * @return a String representing the value of this expression.\n    */\n  def render: String = (r, theta, n) match {\n    case (Number.one, Number.zero, 1) => \"1\"\n    case (Number.one, Number.pi, 1) => \"-1\"\n    case (Number.one, Number.minusPi, 1) => \"-1\"\n    // TODO combine these cases that all require rAsString\n    case (_, _, 2) =>\n      val rAsString = r.render\n      theta.nominalValue match {\n        case Value(0) | Value(_, Rational.zero) | Value(_, _, 0.0) =>\n          \"\\u00b1\" + rAsString // +-\n        case _ =>\n          s\"${rAsString}e∧${showImaginary(polar = true)}\"\n      }\n    case (_, _, 3) =>\n      val rAsString = r.render\n      theta.nominalValue match {\n        case Value(0) | Value(_, Rational.zero) | Value(_, _, 0.0) =>\n          s\"{$rAsString, ±${rAsString}e∧${showImaginary(polar = true, 1, 3)}}\"\n        case _ =>\n          s\"${rAsString}e∧${showImaginary(polar = true)}\"\n      }\n    // TODO handle the case where n is greater than 2\n    case _ =>\n      val rAsString = r.render\n      val w = showImaginary(polar = true)\n      if (w == \"0\") rAsString else s\"${rAsString}e∧$w\"\n  }\n\n  /**\n    * Adds this ComplexPolar instance to another Complex.\n    * The operation is performed by converting this ComplexPolar instance to its Cartesian representation\n    * and then delegating to the `doAdd` method of the Cartesian representation.\n    *\n    * @param complex the other Complex to be added.\n    * @return the result of adding this ComplexPolar to the given Complex.\n    */\n  def doAdd(complex: Complex): Complex =\n    convertToCartesian(this).doAdd(complex)\n\n  /**\n    * Multiplies this ComplexPolar instance with another Complex.\n    * If the input is of type ComplexPolar, the multiplication is performed\n    * in polar form using the magnitude and phase (angle).\n    *\n    * @param complex the other Complex to multiply with.\n    * @return the product as a Complex.\n    * @note Throws ComplexException if the given Complex is not a ComplexPolar instance.\n    */\n  def doMultiply(complex: Complex): Complex = complex match {\n    case ComplexPolar(a, b, _) =>\n      make(r `doMultiply` a, theta `doAdd` b)\n    case _ =>\n      throw ComplexException(\"logic error: ComplexPolar.doMultiply\")\n  }\n\n  /**\n    * Constructs a new ComplexPolar instance using the given parameters.\n    *\n    * @param a the first parameter, generally representing the modulus (magnitude) of the complex number\n    * @param b the second parameter, generally representing the argument (angle) of the complex number in radians\n    * @return a BaseComplex instance, represented as a ComplexPolar\n    */\n  def make(a: Number, b: Number): BaseComplex =\n    ComplexPolar(a, b)\n\n  /**\n    * Method to return this Field as a Real, if possible.\n    * If this is a Real number x, return Some(x) otherwise, return None.\n    *\n    * TESTME\n    *\n    * @return an Option[Real].\n    */\n  def asReal: Option[Real] =\n    if (isReal) convertToCartesian(this).asReal else None\n\n  /**\n    * Method to determine if this Complex is real-valued (i.e. the point lies on the real axis).\n    * TODO fix this properly. We can only really answer this question knowing with branch we're talking about.\n    *\n    * @return true if the angle theta is a multiple of pi.\n    */\n  def isReal: Boolean =\n    theta.factor == Radian && Value.maybeInt(theta.nominalValue).isDefined\n\n  /**\n    * Determine the \"sign\" of this field.\n    * For a real-valued quantity (Real or Number), we try to determine if it is to the right, left or at the origin.\n    * For a complex number, we get the signum of the real part.\n    *\n    * TESTME\n    *\n    * @return +1 if to the right of the origin, -1 if to the left, 0 if at the origin.\n    */\n  def signum: Int =\n    convertToCartesian(this).signum\n\n  /**\n    * Computes the absolute value (magnitude) of this ComplexPolar instance.\n    * The calculation is performed using the Cartesian representation of the complex number.\n    * NOTE very arbitrary.\n    *\n    * @return the absolute value as a Numerical.\n    */\n  def abs: Numerical = convertToCartesian(this).abs\n}\n\n/**\n  * Companion object for the ComplexPolar class.\n  * Provides factory methods for creating instances of ComplexPolar with various parameters.\n  */\nobject ComplexPolar {\n  /**\n    * Creates a ComplexPolar object based on the provided magnitude.\n    * If the input number has a root (NthRoot), it calculates using the root and sets a default angle.\n    * Otherwise, it uses zero as the angle.\n    *\n    * @param r a Number representing the magnitude of the ComplexPolar object\n    * @return a ComplexPolar object with the specified magnitude and calculated or default angle\n    */\n  def apply(r: Number): ComplexPolar = r match {\n    case Number(_, NthRoot(n)) =>\n      apply(r, Number.zeroR, n)\n    case _ =>\n      apply(r, Number.zeroR)\n  }\n\n  /**\n    * Creates a ComplexPolar object from an integer magnitude and a specified angle.\n    * TESTME\n    *\n    * @param r     an integer representing the radius (magnitude) of the ComplexPolar object\n    * @param theta a Number representing the angle (theta) of the ComplexPolar object\n    * @return a ComplexPolar object with the specified magnitude and angle\n    */\n  def apply(r: Int, theta: Number): ComplexPolar =\n    apply(Number(r), theta)\n\n  /**\n    * Factory method to create a ComplexPolar instance using the specified magnitude and angle.\n    *\n    * @param r     the magnitude of the ComplexPolar object, represented as a Number\n    * @param theta the angle of the ComplexPolar object, represented as a Number\n    * @return a ComplexPolar instance with the specified magnitude and angle, and a default branch count of 1\n    */\n  def apply(r: Number, theta: Number): ComplexPolar =\n    apply(r, theta, 1)\n\n  /**\n    * Constructs a ComplexPolar object based on the given magnitude, angle, and root count.\n    * Adjusts or modulates the angle as necessary based on its type and value.\n    *\n    * @param r     the magnitude of the ComplexPolar object, represented as a Number\n    * @param theta the angle of the ComplexPolar object, represented as a Number in radians\n    * @param n     the root count, specifying the number of branches; typically an integer greater than or equal to 1\n    * @return a ComplexPolar object with the specified magnitude, angle (modulated if necessary), and root count\n    * @note Throws CoreException if the provided angle does not match the expected format or type\n    */\n  def apply(r: Number, theta: Number, n: Int): ComplexPolar = theta match {\n    case ExactNumber(x, Radian) if Value.signum(x) == 0 =>\n      new ComplexPolar(r, zeroR, n)\n    case ExactNumber(_, Radian) =>\n      new ComplexPolar(r, theta.modulate, n)\n    case Number(_, Radian) =>\n      new ComplexPolar(r, theta.modulate, n)\n    case _ =>\n      throw CoreException(s\"no match for $theta\")\n  }\n\n  /**\n    * Method to create a ComplexPolar object with two branches.\n    *\n    * @param x a Number representing the real part.\n    * @return a ComplexPolar of magnitude x, and two points along the x-axis the 0 mid-way between.\n    */\n  def ±(x: Number): Field =\n    ComplexPolar(x, zeroR, 2)\n}\n\n/**\n  * A case class representing a custom exception type called ComplexException.\n  *\n  * This exception is initialized with a string message that describes the error.\n  *\n  * @param str The message associated with this exception.\n  */\ncase class ComplexException(str: String) extends Exception(str)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/main/scala/com/phasmidsoftware/number/core/numerical/BaseComplex.scala b/core/src/main/scala/com/phasmidsoftware/number/core/numerical/BaseComplex.scala
--- a/core/src/main/scala/com/phasmidsoftware/number/core/numerical/BaseComplex.scala	(revision 79a04e6d8be0ac7d5aa1e9f007844203f4b8c4fe)
+++ b/core/src/main/scala/com/phasmidsoftware/number/core/numerical/BaseComplex.scala	(date 1770437022769)
@@ -563,6 +563,11 @@
       doAdd(convertToCartesian(c))
   }
 
+  private val realPart: Number = x.doPower(Number.two) `doSubtract` y.doPower(Number.two)
+
+  private val imagPart: Number = x `doMultiply` y `doMultiply` Number.two
+
+  private val squaredValue = ComplexCartesian(realPart, imagPart)
   /**
     * Computes the square of a complex number represented in Cartesian form.
     * The result is a new `ComplexCartesian` value obtained by applying the formula:
@@ -570,8 +575,10 @@
     *
     * @return a `ComplexCartesian` instance representing the square of the original complex number.
     */
-  lazy val square: ComplexCartesian =
-    ComplexCartesian(x.doPower(Number.two) `doSubtract` y.doPower(Number.two), x `doMultiply` y `doMultiply` Number.two)
+  lazy val square: ComplexCartesian = {
+    println(squaredValue)
+    squaredValue
+  }
 
   /**
     * Yields the inverse of this Complex.
